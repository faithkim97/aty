using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
//https://github.com/Honeybunch/VNKit
//using this since i couldn't figure out any better way of zooming in an editor window
//thanks unity, quality product
using VNKit;
//i need this so i can convert a string to lowercase letters
using System.Text.RegularExpressions;
public class GraphEditorWindow : EditorWindow
{
    //reads what kind of nodes are supposed to be in this editor window
    public virtual void SetupNodeTypes()
    {
        NodeTypes = new List<NodeSearches>();
        NodeSearches[] temp = Resources.LoadAll<NodeSearches>("Node search menu");
        foreach (NodeSearches o in temp)
        {
            if (!NodeTypes.Contains(o))
                NodeTypes.Add(o);
        }
    }
    //the types of nodes we have
    //we use it when we're searching for what kind of new node we want to create
    protected List<NodeSearches> NodeTypes = new List<NodeSearches>();
    //the text of the node type that we want to search for
    string NodeSearch = "";
    //the results of the search
    List<NodeSearches> SearchResults = new List<NodeSearches>();
    //find the node that we want to create
    //also it wouldn't have killed you to make a .Contains override that isn't case sensitive
    void FindNodes()
    {
        SearchResults = new List<NodeSearches>();
        for (int i = 0; i < NodeTypes.Count; i++)
        {
            NodeSearches temp = NodeTypes[i];
            if (temp.DisplayName.ToLower().Contains(NodeSearch.ToLower()))
            {
                SearchResults.Add(temp);
            }
        }
    }
    //display the results of the search
    void DisplayNodeResults()
    {
        RightClickMenu.height = 30 + SearchResults.Count * 30;
        Rect buttonrect = new Rect(mousepos.x, mousepos.y + 30, 100, 20);
        for (int i = 0; i < SearchResults.Count; i++)
        {
            NodeSearches temp = SearchResults[i];
            if (GUI.Button(buttonrect, temp.DisplayName))
            {
                Node node = CreateInstance(temp.InstanceName) as Node;
                AddNode(node);
            }
            buttonrect.y += 20;
        }
    }
    //the node editor
    //we need a reference to it so we can do the SetupNodeTypes function (alternatively it would have to be static, but then we can't make it virtual)
    static GraphEditorWindow window;
    //the CURRENT event
    protected Event e;
    //should we show the search menu
    protected bool showPosition;
    //the mouse position
    protected Vector2 mousepos;
    //the acceptable rectangle of the search menu
    //if you click outside of it, the search menu disappears
    protected Rect RightClickMenu = new Rect(0, 0, 200, 20);
    //stores all the nodes
    protected ScriptTemplate canvas;
    //on initialization import the node types. there's a button for that too, just in case you're adding new nodes
    [MenuItem("Window/Node Editor")]
    static void Init()
    {
        window = (GraphEditorWindow)EditorWindow.GetWindow(typeof(GraphEditorWindow));
        window.SetupNodeTypes();
    }
    //doing this as a string, because i can't find anything like an IntField in the GUI api
    //great job keeping up the outdated code
    string StartNode = "";
    //draw all the buttons and nodes
    protected virtual void OnGUI()
    {
        //draw the nodes and curves, handle zooming/panning, also check if we want the search menu
        DrawNodes();
        if (canvas == null)
        {
            CreateNewCanvas();
        }
        Rect buttonRect = new Rect(position.width - 120, 10, 100, 20);
        //reimports the node types
        //you only need this if you had the editor window open when you were creating new node subclasses
        if (GUI.Button(buttonRect, "Reload nodes"))
        {
            SetupNodeTypes();
        }
        buttonRect.y += 25;
        //clear the canvas
        if (GUI.Button(buttonRect, "new canvas"))
        {
            CreateNewCanvas();
        }
        buttonRect.y += 25;
        //save it
        if (GUI.Button(buttonRect, "save canvas"))
        {
            SaveCanvas();
        }
        buttonRect.y += 25;
        //load it
        if (GUI.Button(buttonRect, "load canvas"))
        {
            LoadCanvas();
        }
        buttonRect.y += 25;
        //the name that we're gonna be saving/loading 
        canvas.name = GUI.TextField(buttonRect, canvas.name);
        buttonRect.y += 25;
        //the start of the canvas
        //HOW THE FUCK DO YOU NOT HAVE ANY NUMERICAL INPUT FOR THE GUI
        StartNode = GUI.TextField(buttonRect, StartNode);
        StartNode = Regex.Replace(StartNode, @"[^0-9]", "");
        if (StartNode != "")
        {
            canvas.StartNode = int.Parse(StartNode);
        }
        else
        {
            canvas.StartNode = 0;
        }
    }
    //create a new canvas
    //override versions of this create the ScriptTemplate subclasses
    protected virtual void CreateNewCanvas()
    {
        ClearMemory();
        canvas = CreateInstance<ScriptTemplate>();
    }
    //no clue if it actually clears the memory
    //that could just be my toaster/chrome/unity fucking with me
    protected void ClearMemory()
    {
        if (canvas != null)
        {
            if (canvas.nodes.Count > 0)
            {
                for (int i = canvas.nodes.Count - 1; i >= 0; i--)
                {
                    DestroyImmediate(canvas.nodes[i]);
                }
            }
            DestroyImmediate(canvas);
        }
    }
    //where we're saving/loading
    protected string assetPathAndName;
    //copies all the nodes from one list to the other (we want new nodes, not references to existing ones)
    protected void CopyList(ScriptTemplate a, ScriptTemplate b)
    {

        a.name = b.name;
        a.nodes = new List<Node>();
        a.StartNode = b.StartNode;
        //we're doing the loop twice, since we have to create all the nodes before assigning their connections
        for (int i = 0; i < b.nodes.Count; i++)
        {
            Node temp = CreateInstance(b.nodes[i].GetType()) as Node;
            temp.name = i.ToString() + "-" + b.nodes[i].Type();
            a.nodes.Add(temp);
            a.nodes[i].ID = i;
            b.nodes[i].ID = i;
            a.nodes[i].parent = a;
        }
        for (int i = 0; i < b.nodes.Count; i++)
        {
            b.nodes[i].CopyTo(a.nodes[i]);
        }
    }
    protected virtual void LoadCanvas()
    {
        assetPathAndName = "Assets/NodeEditor/Resources/" + canvas.name + ".asset";
        ScriptTemplate newc = AssetDatabase.LoadAssetAtPath<ScriptTemplate>(assetPathAndName);
        //reset the canvas, since we don't want it to reference a file in the projects, but to be it's own thing
        CreateNewCanvas();
        CopyList(canvas, newc);
    }
    protected virtual void SaveCanvas()
    {
        assetPathAndName = "Assets/NodeEditor/Resources/" + canvas.name + ".asset";
        ScriptTemplate outPut = AssetDatabase.LoadAssetAtPath(assetPathAndName, typeof(ScriptTemplate)) as ScriptTemplate;
        //check if the script already exists
        if (outPut != null)
        {
            for (int i = 0; i < outPut.nodes.Count; i++)
            {
                DestroyImmediate(outPut.nodes[i], true);
            }
            CopyList(outPut, canvas);
            for (int i = 0; i < outPut.nodes.Count; i++)
            {
                AssetDatabase.AddObjectToAsset(outPut.nodes[i], assetPathAndName);
            }
        }
        else
        {
            outPut = CreateInstance<ScriptTemplate>();
            CopyList(outPut, canvas);
            AssetDatabase.CreateAsset(outPut, assetPathAndName);
            for (int i = 0; i < outPut.nodes.Count; i++)
            {
                //doing this so that the nodes don't become the main asset
                //seriously why hasn't that been fixed yet
                //oh wait, this still doesn't work
                //seriously, fix this shit you fucking hacks
                outPut.nodes[i].hideFlags = HideFlags.HideInHierarchy;
                AssetDatabase.AddObjectToAsset(outPut.nodes[i], assetPathAndName);
            }
        }
        AssetDatabase.SaveAssets();
        AssetDatabase.Refresh();
    }
    //check if we want the right click menu active
    void HandleRightClickEvent()
    {
        e = Event.current;

        if (e.type == EventType.MouseDown)
        {
            if (e.button == 1)
            {
                showPosition = true;
                mousepos = e.mousePosition;
                RightClickMenu = new Rect(mousepos.x - 20, mousepos.y, 200, 110);
                Repaint();
                NodeSearch = "";
            }
            else
            {
                if (!RightClickMenu.Contains(e.mousePosition))
                {
                    showPosition = false;
                    Repaint();
                }
            }
        }
        if (showPosition == true)
        {
            OnRightClick();
        }
    }
    //doesn't actually draw the nodes, just handles the zoom area
    void DrawNodes()
    {
        testRect = new Rect(5, 5, position.width - 140, position.height - 5);
        GUILayout.BeginVertical();
        {
            GUILayout.Box(GUIContent.none, GUILayout.ExpandWidth(true), GUILayout.MaxHeight(testRect.height), GUILayout.MaxWidth(position.width - 140));
            EditorZoomArea.Begin(zoom, new Rect(testRect.x + 5, testRect.y, position.width - 150, testRect.height - 10));
            BeginWindows();
            HandleRightClickEvent();
            HandleEvents();
            EndWindows();
            EditorZoomArea.End();
        }
        GUILayout.EndVertical();
    }
    //creates the search menu, also focuses on it's text field (supposedly, i keep fucking that up and changing the canvas name)
    protected void OnRightClick()
    {
        Rect buttonrect = new Rect(mousepos.x, mousepos.y + 10, 140, 20);
        GUI.SetNextControlName("searchfield");
        NodeSearch = GUI.TextField(buttonrect, NodeSearch);
        GUI.FocusControl("searchfield");
        if (NodeSearch != "")
        {
            //find the searched nodes
            FindNodes();
            //display the results, if there are any
            if (SearchResults.Count > 0)
            {
                DisplayNodeResults();
            }
        }

    }
    //add a new node 
    protected void AddNode(Node temp)
    {
        temp.parent = canvas;
        temp.pos = new Rect(mousepos.x - 120, mousepos.y, 120, 100);
        temp.name = canvas.nodes.Count.ToString() + "-" + temp.Type();
        canvas.nodes.Add(temp);
        showPosition = false;
        Repaint();
    }
    //i have no idea how this shit works
    Vector2 zoomOrigin = Vector2.zero;
    Vector2 zoomDelta = Vector2.zero;
    //the zoom scale
    float zoom = 1;
    Rect testRect = new Rect(5, 5, 400, 680);
    void HandleEvents()
    {
        Vector2 mousePos = Event.current.mousePosition;

        if (Event.current.type == EventType.ScrollWheel)
        {
            Vector2 delta = Event.current.delta;
            Vector2 zoomedMousePos = (mousePos - testRect.min) / zoom + zoomOrigin;

            float oldZoomScale = zoom;

            float zoomDelta = -delta.y / 150.0f;
            zoom += zoomDelta * 4;
            zoom = Mathf.Clamp(zoom, 0.1f, 2.0f);

            zoomOrigin += (zoomedMousePos - zoomOrigin) - (oldZoomScale / zoom) * (zoomedMousePos - zoomOrigin);

            Event.current.Use();
        }

        if (Event.current.type == EventType.MouseDrag && Event.current.button == 2)
        {
            zoomDelta = Event.current.delta;
            zoomDelta /= zoom * 2;
            zoomOrigin += zoomDelta;
            Event.current.Use();
        }
        else
        {
            zoomDelta = Vector2.zero;
        }
        if (canvas != null)
        {
            for (int i = 0; i < canvas.nodes.Count; i++)
            {
                Node temp = canvas.nodes[i];
                temp.ID = i;
                //draw the nodes
                temp.pos = GUILayout.Window(i, new Rect(temp.pos.x + zoomDelta.x, temp.pos.y + zoomDelta.y, temp.pos.width, temp.pos.height), temp.DrawNode, i.ToString() + "-" + temp.Type());
                for (int j = 0; j < temp.connectedTo.Count; j++)
                {//draw the bezier curves
                    temp.DrawNodeCurve(temp, temp.connectedTo[j]);
                }
            }
        }
    }
}
