using UnityEngine;
using System.Collections;
using System.Collections.Generic;
//check whether we're in the editor or not
#if UNITY_EDITOR
using UnityEditor;
#endif
//the base class for all nodes
public class Node : ScriptableObject
{
    //where a bezier curve should land on the left side of this node
    //a lot of the nodes override this, since they might want the connection to point towards a label/field
    public virtual Vector3 Left(Node node)
    {
        return new Vector3(pos.x, (2 * pos.y + pos.height) / 2, 0);
    }
    //where a bezier curve should start on the right side of this node
    public virtual Vector3 Right(Node node)
    {
        return new Vector3(pos.x + pos.width, (2 * pos.y + pos.height) / 2, 0); ;
    }
    //the canvas
    [HideInInspector]
    public ScriptTemplate parent;
    //lists of nodes that we're connected to
    public List<Node> connectedTo = new List<Node>(), referencedBy = new List<Node>();
    //id in the canvas list
    public int ID;
    //position in the window
    public Rect pos = new Rect(100, 100, 120, 100);
    //what kind of node this is
    public virtual string Type() { return "node"; }
    //what kind of base this node is (usually node/float/bool/branch/output)
    public virtual string BaseType() { return "node"; }
    //are we attaching a node to another node
    static bool attaching = false;
    //the node we're attaching to this node
    public static Node attachNode = null;
    //the attach function
    //certain node subclasses override this since they might have aditional variables that need to be set depending on what we're connecting to them
    public virtual void Attach()
    {
        attachNode.connectedTo.Add(this);
        referencedBy.Add(attachNode);
        //if there's a branch that isn't an If, tell it that this is it's next step
        //sadly i couldn't figure out a way to do this with class inheritance. rip spaghetti code
        if ((attachNode.BaseType() == "Branch" || attachNode.BaseType() == "Output" || attachNode.BaseType() == "Function") && attachNode.Type() != "If" && attachNode.Type() != "Switch")
        {
            Branch temp = attachNode as Branch;
            temp.value = this;
        }
    }
    //swaps two nodes in the connections/references
    //used when converting variables to objects, or in switch/string append nodes
    public void ReorderConnections(Node node1, Node node2)
    {
        if (connectedTo.Contains(node1) && connectedTo.Contains(node2))
        {
            int index1 = FindIndexConnections(node1);
            int index2 = FindIndexConnections(node2);
            connectedTo[index1] = node2;
            connectedTo[index2] = node1;
        }
    }
    public void ReorderReferences(Node node1, Node node2)
    {
        if (referencedBy.Contains(node1) && referencedBy.Contains(node2))
        {
            int index1 = FindIndexReferences(node1);
            int index2 = FindIndexReferences(node2);
            referencedBy[index1] = node2;
            referencedBy[index2] = node1;
        }
    }
    //find the connectedTo index of a node, since list.Find makes no sense
    public int FindIndexConnections(Node node1)
    {
        for (int i = 0; i < connectedTo.Count; i++)
        {
            if (connectedTo[i] == node1)
            {
                return i;
            }
        }
        return 0;
    }
    //same thing for the references
    public int FindIndexReferences(Node node1)
    {
        for (int i = 0; i < referencedBy.Count; i++)
        {
            if (referencedBy[i] == node1)
            {
                return i;
            }
        }
        return 0;
    }

#if UNITY_EDITOR
    //option to reorder the connected/referenced nodes
    //newfeg can't into triforce
    protected void ReorderReferencesUpDown(int i)
    {

        if (GUILayout.Button("▲",GUILayout.Width(30)))
        {
            if (FindIndexReferences(referencedBy[i]) > 0)
            {
                ReorderReferences(referencedBy[i], referencedBy[i - 1]);
            }
        }
        if (GUILayout.Button("▼", GUILayout.Width(30)))
        {
            if (FindIndexReferences(referencedBy[i]) < referencedBy.Count - 1)
            {
                ReorderReferences(referencedBy[i], referencedBy[i + 1]);
            }
        }
    }
    protected void ReorderConnectionsUpDown(int i)
    {

        if (GUILayout.Button("▲", GUILayout.Width(30)))
        {
            if (FindIndexConnections(connectedTo[i]) > 0)
            {
                ReorderConnections(connectedTo[i], connectedTo[i - 1]);
            }
        }
        if (GUILayout.Button("▼", GUILayout.Width(30)))
        {
            if (FindIndexConnections(connectedTo[i]) < connectedTo.Count - 1)
            {
                ReorderConnections(connectedTo[i], connectedTo[i + 1]);
            }
        }
    }
    //actually there's probably no reason to make this a virtual void
    //still leaving it like that just in case you want to change something depending on the node type
    public virtual void DrawNodeCurve(Node node1, Node node2)
    {
        Vector3 start = node1.Right(node2);
        Vector3 end = node2.Left(node1);
        Vector3 startTan = start + Vector3.right * 50;
        Vector3 endTan = end + Vector3.left * 50;
        Handles.DrawBezier(start, end, startTan, endTan, Color.black, null, 3);
    }
    //draw the node in the editor
    //also handle when to attach/detach/delete
    public virtual void DrawNode(int id = 0)
    {
        ID = id;
        if (GUILayout.Button("Attach"))
        {
            if (attaching == false)
            {
                attaching = true;
                attachNode = this;
            }
            else
            {
                if (attachNode != this && !attachNode.connectedTo.Contains(this))
                {
                    Attach();
                    if (attachNode.Type() == "If" && attachNode.connectedTo.Count > 2)
                    {
                        attachNode.ReorderConnections(attachNode.connectedTo[1], this);
                        attachNode.connectedTo.RemoveAt(2);
                    }
                }
                attaching = false;
                attachNode = null;

            }
        }
        if (GUILayout.Button("Detach"))
        {
            Detach();
        }
        if (GUILayout.Button("Delete"))
        {
            Detach();
            Delete();
        }
        GUI.DragWindow();
    }
#endif
    //detach function
    protected void Detach()
    {
        for (int i = connectedTo.Count - 1; i >= 0; i--)
        {
            connectedTo[i].referencedBy.Remove(this);
            connectedTo.RemoveAt(i);
        }
        for (int i = referencedBy.Count - 1; i >= 0; i--)
        {
            referencedBy[i].connectedTo.Remove(this);
            referencedBy.RemoveAt(i);
        }
    }
    //copy function, used when saving/loading canvases since we want new nodes, not references to existing ones
    public virtual void CopyTo(Node other)
    {
        other.pos = new Rect(pos.x, pos.y, other.pos.width, other.pos.height);
        other.name = ID.ToString() + "-" + Type();
        for (int j = 0; j < connectedTo.Count; j++)
        {
            other.connectedTo.Add(other.parent.nodes[connectedTo[j].ID]);
        }
        for (int j = 0; j < referencedBy.Count; j++)
        {
            other.referencedBy.Add(other.parent.nodes[referencedBy[j].ID]);
        }
    }
    //delete the node to free up space
    protected void Delete()
    {
        parent.nodes.Remove(this);
        DestroyImmediate(this);
    }
}
